package org.technologybrewery.shell.exec;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.event.Level;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class CommandHelper {
    private static final Logger logger = LoggerFactory.getLogger(CommandHelper.class);

    private final File workingDirectory;
    private String baseCmd;
    public CommandHelper(File workingDirectory, String baseCmd) {
        this.workingDirectory = workingDirectory;
        this.baseCmd = baseCmd;
    }

    protected void setBaseCommand(String baseCommand) { this.baseCmd = baseCommand; }


    /**
     * Executes a command with the given arguments, logs the executed
     * command, and returns the resultant process output as a string. This method
     * should be utilized when performing downstream logic based on the output of a
     * Poetry command, or it is desirable to not show the command's generated
     * stdout.
     *
     * @param arguments
     * @return
     * @throws ShellExecutionException
     */
    public ShellExecutionOutput execute(List<String> arguments) throws ShellExecutionException {
        return execute(arguments, Level.INFO);
    }

    private ShellExecutionOutput execute(List<String> arguments, Level logLevel) {
        ProcessExecutor executor = createExecutor(arguments);
        if (Level.DEBUG.equals(logLevel) && logger.isDebugEnabled()) {
            logger.debug("Executing command: {} {}", baseCmd, StringUtils.join(arguments, " "));

        } else if (Level.INFO.equals(logLevel) && logger.isInfoEnabled()) {
            logger.info("Executing command: {} {}", baseCmd, StringUtils.join(arguments, " "));

        }

        return executor.executeAndGetResult(logger);
    }

    /**
     * Executes a command with the given arguments, logs the executed command at the debug level,
     * and returns the resultant process output as a string.
     *
     * @param arguments
     * @return
     * @throws ShellExecutionException
     */
    public ShellExecutionOutput executeWithDebugLogging(List<String> arguments) throws ShellExecutionException {
        return execute(arguments, Level.DEBUG);
    }

    protected ProcessExecutor createExecutor(List<String> arguments) {
        List<String> fullCommandArgs = new ArrayList<>();
        fullCommandArgs.add(baseCmd);
        fullCommandArgs.addAll(arguments);
        return new ProcessExecutor(workingDirectory, fullCommandArgs, Platform.guess(), null);
    }

    /**
     * Executes a Poetry command with the given arguments, logs the executed
     * command, logs the stdout/stderr generated by the process, and returns the
     * process exit code. This method should be utilized when it is desirable to
     * immediately show all of the stdout/stderr produced by a Poetry command for
     * diagnostic purposes.
     *
     * @param arguments
     * @return
     * @throws ShellExecutionException
     */
    public int executeAndLogOutput(List<String> arguments) throws ShellExecutionException {
        if (logger.isInfoEnabled()) {
            logger.info("Executing command: {} {}", baseCmd, StringUtils.join(arguments, " "));
        }
        ProcessExecutor executor = createExecutor(arguments);
        return executor.executeAndRedirectOutput(logger);
    }


    /**
     * Similar to {@link #executeAndLogOutput(List)}, except the executed
     * command that is logged obfuscates/masks any given command arguments that are
     * marked as sensitive. This method should be utilized if any Poetry command
     * line arguments contain sensitive values that are not desirable to log, such
     * as passwords.
     *
     * @param argAndIsSensitivePairs
     * @return
     * @throws ShellExecutionException
     */
    public int executeWithSensitiveArgsAndLogOutput(List<Pair<String, Boolean>> argAndIsSensitivePairs)
            throws ShellExecutionException {
        if (logger.isInfoEnabled()) {
            List<String> argsWithSensitiveArgsMasked = argAndIsSensitivePairs.stream()
                    .map(pair -> pair.getRight() ? "XXXX" : pair.getLeft()).collect(Collectors.toList());
            logger.info("Executing Poetry command: {} {}", baseCmd,
                    StringUtils.join(argsWithSensitiveArgsMasked, " "));
        }
        ProcessExecutor executor = createExecutor(
                argAndIsSensitivePairs.stream().map(Pair::getLeft).collect(Collectors.toList()));
        return executor.executeAndRedirectOutput(logger);
    }
}
